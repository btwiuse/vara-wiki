---
title: Vara-Ethereum 跨链桥 - 技术概述
sidebar_position: 2
sidebar_label: 技术概述
---

# Vara ↔ Ethereum 跨链桥技术概述

:::success
**安全第一**  
跨链桥架构已通过专业安全审计审查。所有关键发现，包括边缘情况——已在最终实现中得到解决。

审计确认所有核心组件——包括消息验证、代币逻辑和中继器激励——在真实世界条件下都能正确安全地运行。
[📄 安全审计报告 (PDF)](https://github.com/gear-tech/gear-bridges/blob/main/audits/ethernal.pdf)
:::

:::important
要探索代码，请导航至：
[🔗 跨链桥实现仓库](https://github.com/gear-tech/gear-bridges)
:::

## 跨链桥背后的技术

Vara ↔ Ethereum 跨链桥是深度技术架构和在跨链互操作性及密码学领域真实世界经验的产物。它汇集了一套专为<u>安全性、可扩展性和无需信任执行</u>而构建的技术——同时保持与现有以太坊基础设施的兼容性。

跨链桥的基础是一个现代化的密码学堆栈，包括用于高速递归零知识证明的 `Plonky2` 和用于在以太坊合约内进行 zk 证明验证的 `GNARK`。这些工具使跨链桥能够验证验证者共识和消息真实性，而无需泄露敏感数据——这是去中心化网络的关键特性。

为确保最低的 gas 成本和最大的可验证性，系统依赖 `Merkle 树` 进行紧凑的消息承诺，并集成 `以太坊信标链` API 和 `同步委员会` 来在 Vara 端独立验证以太坊区块最终性。在 Vara 上，桥接逻辑由 **Gear 运行时** 和一套专门的程序和模块提供支持，这些程序和模块协调消息队列、验证者集合和轻客户端行为。

这个组合堆栈使跨链桥能够在没有可信中介的情况下运行——每个证明、消息和区块都可以在链上通过密码学验证，为以太坊和 Vara 之间安全且可扩展的消息系统奠定了基础。

## 概念流程：跨链桥如何工作

从用户的角度来看，在 Vara 和以太坊之间桥接代币或数据可能感觉像是一个简单的操作——点击、确认、完成。但在底层，系统遵循严格的流程，确保只有最终确定的、经过验证的信息才会跨链传输。

### 从 Vara 到 Ethereum

该过程从最终确定的区块开始。当用户执行生成到以太坊消息的操作时——例如锁定 VARA 代币。这些消息由 `gear_eth_bridge` 模块收集并存储在出站队列中。

每次在 Vara 上产生一个区块时，都会计算消息队列的新 Merkle 根。然后中继器——无需许可的去中心化参与者——接管。它们生成一个零知识证明，证明这个 Merkle 根是由 Vara 上的活跃验证者集合签名的。这个证明以及区块号和验证者快照等元数据被提交到以太坊上的 `Proof Verification Contract`。该合约使用 `gnark` 检查证明的有效性。

如果 zk 证明有效，以太坊记录 Merkle 根并将其视为已批准的真相来源。

之后，来自 Vara 的任何单个消息都可以通过 `Bridge Message Contract` 提交到以太坊，同时附带包含证明的 Merkle 证明。合约检查该消息：

- 属于已批准的 Merkle 根
- 尚未被处理

如果两个条件都满足，消息被标记为已使用，并触发相应的操作（例如，铸造代币）。

### 从 Ethereum 到 Vara

在相反方向上，系统不使用 zk 证明。相反，它依赖以太坊的原生最终性机制和事件日志。

中继器持续监控以太坊的**信标链和同步委员会**——一个轮换的以太坊验证者组，它们签署最终确定的区块头。一旦一个区块被最终确定，中继器将区块头和相关的同步委员会签名提交给 Vara。

在 Vara 端，一个 `checkpoint light client` 程序使用来自 `sync committee` 的聚合 BLS 签名验证提交的区块确实已被最终确定。

一旦 Vara 接受该区块为最终确定，在以太坊上发出的任何相关事件（例如，来自 wVARA Manager 合约的 Burn 事件）都可以通过 Merkle 证明来证明。这些证明随后在 Vara 端被消费，例如 VFT Manager 程序，它执行适当的链上逻辑，如铸造 VARA 代币。

:::note
**VFT Manager**，简单来说，是与跨链桥交互并向代币合约发送命令以触发相应操作（如铸造或解锁代币）的合约。
:::

:::note

**示例交易流程**

让我们来看一个端到端的例子：

1. 用户想要将 VARA 转移到以太坊。
2. 他们通过 Vara 端的 VFT Manager 锁定 100 VARA。
3. 此操作生成一条消息，存储在出站队列中。
4. 最终确定后，`gear_eth_bridge` 获取一个新的 Merkle 根。
5. 中继器生成一个 zk 证明并将其提交到以太坊的 `Proof Verification Contract`。
6. 根被接受，现在可以提交消息——通常由中继器——同时附带 Merkle 证明。
7. `wVARA Manager ERC-20 contract` 向用户地址铸造 100 wVARA。

反向流程（在以太坊上销毁 wVARA → 在 Vara 上解锁 VARA）遵循相同的结构但方向相反，检查点、事件和证明通过以太坊轻客户端和 Vara 上的消息验证器流动。

1. 用户将 wVARA 发送到以太坊上的 wVARA Manager 合约并触发 Burn 事件。
2. 销毁记录在由以太坊信标链最终确定的区块中。
3. 中继器将最终确定的区块头和签名提交给 Vara 的轻客户端。
4. Vara 接受该区块并通过 VFT Manager 处理事件。
5. 原生 VARA 被铸造或解锁到用户在 Vara 上的账户。

这种双模型架构——一个方向使用 zk 证明，另一个方向使用共识/基于事件的验证——确保了效率和鲁棒性。

:::

## 传输层

传输层是跨链桥的核心——负责确保消息在两个网络之间正确收集、验证和传递。这些组件确保系统的每一端使用相同的语言——安全且一致地通信。

### Vara 端组件

这里的主要参与者是 `gear_eth_bridge pallet`。它作为<u>出站</u>和<u>入站</u>消息的协调器：

- 维护当前的验证者集合
- 跟踪最终确定的区块和出站消息队列
- 计算最终确定消息批次的 Merkle 根
- 存储 ZK 证明生成所需的元数据

其他重要模块是程序：

`Checkpoint Light Client` —— 一个最小的以太坊信标链客户端，存储最终确定的区块头和同步委员会集合。它：

- 接受新最终确定的区块头并在验证后存储它们
- 实现对以太坊端数据的无需信任验证

`Ethereum Event Client` —— 该程序通过以下方式处理以太坊端事件：

- 与检查点轻客户端交叉检查数据
- 验证确认交易是区块一部分的 Merkle Patricia 证明
- 解码交易收据和事件

`Historical Proxy` —— 用户和多个版本的以太坊事件客户端之间的路由层。它根据以太坊的槽号选择正确版本的事件客户端来处理给定请求。

:::info
为什么需要 Historical Proxy？

以太坊随时间演变，数据和客户端结构可能发生变化。Historical Proxy 有助于平稳管理这一点——它总是根据区块的槽选择正确的客户端版本。
:::

### Ethereum 端组件

以太坊托管几个处理桥接逻辑的关键合约。每个组件在消息处理和状态验证中都扮演着特定角色：

`Proof Verification Contract` —— 使用 `gnark` 证明系统验证中继器提交的 zk 证明。

`Relayer Contract` —— 接受来自中继器的证明和 Merkle 根，并在它们被接受时发出事件。

`MessageQueue Contract` —— 验证包含在 Merkle 根中的消息，并确保它们之前未被使用过。

`ProxyUpdater Contract` —— 处理系统级更新，例如治理批准的桥接组件更改。

`Event Submission Interface` —— 中继器提交最终确定的以太坊区块和事件数据的辅助合约，用于从以太坊向 Vara 发送消息时。

## 中继器

中继器在跨链桥的跨链通信模型中扮演着关键角色。这些是独立的、无需许可的参与者，在以太坊和 Vara 之间传递消息、区块头和证明。

中继器不验证或解释它们携带的数据。相反，它们充当信使：

- 从 Vara 向以太坊提交 zk 证明和 Merkle 根
- 向 Vara 提交最终确定的以太坊区块头和交易数据

由于跨链桥是**完全无需许可的**，任何人都可以运行中继器——不需要特殊访问权限。这确保了在不同网络条件下的去中心化和可用性。

中继器也可能有经济激励。每个成功的消息传递或区块头提交都可能获得奖励，确保中继器有动力保持在线并维护服务可用性。

它们在设计上是**可替换的、无状态的和独立的**——如果一个停止，另一个可以在没有任何协调的情况下继续。许多可以同时运行。

:::info
**桥接支付合约**

为了激励中继器，系统可选地支持两端的桥接支付机制。
用户在发起跨链消息时自动支付少量费用，中继器稍后可以领取这些费用。这些桥接支付流程不是严格强制的——用户也可以手动中继消息而不支付自动费用，但在实践中，中继器通常需要激励。
:::

:::info
**如果中继器离线会发生什么？**

因为所有数据都存储在链上（以及在 Merkle 树中），所以不会丢失任何东西。一旦中继器或任何新的中继器返回，它可以拾取证明并继续传输。这种设计确保了活性而没有中心故障点。
:::

## 智能合约层：代币逻辑与可扩展性

在传输和验证基础设施之上是代币逻辑层——负责处理两个链上的代币和业务逻辑。

在跨链桥的两侧，架构都围绕两个元素构建：

- 资产管理器（例如，ERC20Manager、VFT Manager）
- 资产合约（例如，ERC-20 代币或 FT 程序）

**管理器**负责：

- 协调代币逻辑——铸造、销毁、锁定或解锁
- 验证和处理已验证的桥接消息

这些管理器与系统中的多个组件协调——例如 Vara 上的 `gear_eth_bridge`，或以太坊上的 `MessageQueue`——以确保只有经过验证和授权的操作发生。

资产合约是独立和模块化的。

### 开发者可扩展性

跨链桥被构建为可扩展和无需许可的。开发者可以：

- 构建自己的代币管理器或消息处理器
- 使用自定义资产（NFT、游戏资产或 DeFi 原语）扩展跨链桥

集成需要经过 DAO 治理——允许社区审查、批准并向跨链桥注册表添加新逻辑

这确保了跨链桥不限于任何特定资产类型，并且可以适应不断发展的生态系统的需求。

## 治理层

治理系统确保跨链桥保持安全、可升级并适应生态系统需求——所有这些都不需要破坏性的硬分叉。

在其核心，跨链桥使用**Substrate 的 OpenGov pallet** 的自定义版本，专门为跨链基础设施适配。该系统允许社区提交提案并进行投票，这些提案可以通过链上执行直接影响跨链桥的行为。

通过提案，跨链桥允许：

- **扩展桥接功能** - 添加新代币、资产或模块而不中断操作。
- **智能合约升级** - 使用代理模式无缝升级以太坊合约，并通过可信管理员消息更新 Vara 上的逻辑。
- **调整经济参数** - 通过提案调整费用、中继器激励和操作限制。
- **紧急控制** - 基于透明的社区共识，在响应关键威胁时暂停或限制桥接活动。

:::info
**实践中的治理**

跨链桥的 DAO 逻辑与其传输层完全集成。通过治理发送的管理消息被智能合约和模块识别，允许在不损害链上安全性的情况下进行受控更新。
:::

:::note
**这对用户意味着什么？**

治理使跨链桥具有弹性和面向未来。任何社区成员都可以提出改进——一旦批准，它们将无缝实施，没有停机时间或手动干预。
:::

---

## 进一步阅读

- [Plonky2 – 递归 SNARKs](https://github.com/0xPolygonZero/plonky2)
- [Gnark – Go 上的 zkSNARKs](https://github.com/ConsenSys/gnark)
- [Ethereum Beacon Chain – 共识规范](https://github.com/ethereum/consensus-specs/tree/dev/specs/bellatrix)
- [Merkle Trees 解释](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/)
- [Substrate OpenGov – 治理模块](https://docs.polkadot.com/polkadot-protocol/onchain-governance/overview/)
